@using Maps
@using System.Threading

<div id="@Id" style="height: 500px"></div>

@functions {
    [Parameter]
    private string Id { get; set; }

    [Parameter]
    private MapOptions Options { get; set; }

    /// <summary>
    /// This event is fired when the viewport bounds have changed.
    /// </summary>
    [Parameter]
    private Action OnBoundsChanged { get; set; }
    private Guid? boundsChangedEventRef;

    /// <summary>
    /// This event is fired when the map center property changes.
    /// </summary>
    [Parameter]
    private Action OnCenterChanged { get; set; }
    private Guid? centerChangedEventRef { get; set; }

    /// <summary>
    /// This event is fired when the user clicks on the map. An ApiMouseEvent with properties for the clicked location is returned unless a place icon was clicked, in which case an IconMouseEvent with a placeid is returned. 
    /// IconMouseEvent and ApiMouseEvent are identical, except that IconMouseEvent has the placeid field. 
    /// The event can always be treated as an ApiMouseEvent when the placeid is not important. 
    /// The click event is not fired if a marker or infowindow was clicked.
    /// </summary>
    [Parameter]
    private Action OnClick { get; set; }
    private Guid? clickEventRef { get; set; }

    /// <summary>
    /// This event is fired when the user double-clicks on the map. 
    /// Note that the click event will also fire, right before this one.
    /// </summary>
    [Parameter]
    private Action OnDoubleClick { get; set; }
    private Guid? doubleClickEventRef { get; set; }

    /// <summary>
    /// This event is repeatedly fired while the user drags the map.
    /// </summary>
    [Parameter]
    private Action OnDrag { get; set; }
    private Guid? dragEventRef { get; set; }

    /// <summary>
    /// This event is fired when the user stops dragging the map.
    /// </summary>
    [Parameter]
    private Action OnDragEnd { get; set; }
    private Guid? dragEndEventRef { get; set; }

    /// <summary>
    /// This event is fired when the user starts dragging the map.
    /// </summary>
    [Parameter]
    private Action OnDragStart { get; set; }
    private Guid? dragStartEventRef { get; set; }

    /// <summary>
    /// This event is fired when the map heading property changes.
    /// </summary>
    [Parameter]
    private Action OnHeadingChanged { get; set; }
    private Guid? headingChangedEventRef { get; set; }

    /// <summary>
    /// This event is fired when the map becomes idle after panning or zooming.
    /// </summary>
    [Parameter]
    private Action OnIdle { get; set; }
    private Guid? idleEventRef { get; set; }

    /// <summary>
    /// This event is fired when the mapTypeId property changes.
    /// </summary>
    [Parameter]
    private Action OnMapTypeIdChanged { get; set; }
    private Guid? mapTypeIdChangedEventRef { get; set; }

    /// <summary>
    /// This event is fired whenever the user's mouse moves over the map container.
    /// </summary>
    [Parameter]
    private Action OnMouseMove { get; set; }
    private Guid? mouseMoveEventRef { get; set; }

    /// <summary>
    /// This event is fired when the user's mouse exits the map container.
    /// </summary>
    [Parameter]
    private Action OnMouseOut { get; set; }
    private Guid? mouseOutEventRef { get; set; }

    /// <summary>
    /// This event is fired when the user's mouse enters the map container.
    /// </summary>
    [Parameter]
    private Action OnMouseOver { get; set; }
    private Guid? mouseOverEventRef { get; set; }

    /// <summary>
    /// This event is fired when the DOM contextmenu event is fired on the map container.
    /// </summary>
    [Parameter]
    private Action OnProjectionChanged { get; set; }
    private Guid? projectionChangedEventRef { get; set; }

    /// <summary>
    /// This event is fired when the DOM contextmenu event is fired on the map container.
    /// </summary>
    [Parameter]
    private Action OnRightClick { get; set; }
    private Guid? rightClickEventRef { get; set; }

    /// <summary>
    /// This event is fired when the visible tiles have finished loading.
    /// </summary>
    [Parameter]
    private Action OnTilesLoaded { get; set; }
    private Guid? tilesLoadedEventRef { get; set; }

    /// <summary>
    /// This event is fired when the map tilt property changes.
    /// </summary>
    [Parameter]
    private Action OnTiltChanged { get; set; }
    private Guid? tiltChangedEventRef { get; set; }

    /// <summary>
    /// This event is fired when the map zoom property changes.
    /// </summary>
    [Parameter]
    private Action OnZoomChanged { get; set; }
    private Guid? zoomChangedEventRef { get; set; }

    protected async override Task OnAfterRenderAsync()
    {
        await MapFunctionJsInterop.Init(Id, Options);;

        if (OnBoundsChanged != null)
            boundsChangedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "bounds_changed", OnBoundsChanged);

        if (OnCenterChanged != null)
            centerChangedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "center_changed", OnCenterChanged);

        if (OnClick != null)
            clickEventRef = await MapEventJsInterop.SubscribeEvent(Id, "click", OnClick);

        if (OnDoubleClick != null)
            doubleClickEventRef = await MapEventJsInterop.SubscribeEvent(Id, "dblclick", OnDoubleClick);

        if (OnDrag != null)
            dragEventRef = await MapEventJsInterop.SubscribeEvent(Id, "drag", OnDrag);

        if (OnDragEnd != null)
            dragEndEventRef = await MapEventJsInterop.SubscribeEvent(Id, "dragend", OnDragEnd);

        if (OnDragStart != null)
            dragStartEventRef = await MapEventJsInterop.SubscribeEvent(Id, "dragstart", OnDragStart);

        if (OnHeadingChanged != null)
            headingChangedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "heading_changed", OnHeadingChanged);

        if (OnIdle != null)
            idleEventRef = await MapEventJsInterop.SubscribeEvent(Id, "idle", OnIdle);

        if (OnMapTypeIdChanged != null)
            mapTypeIdChangedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "maptypeid_changed", OnMapTypeIdChanged);

        if (OnMouseMove != null)
            mouseMoveEventRef = await MapEventJsInterop.SubscribeEvent(Id, "mousemove", OnMouseMove);

        if (OnMouseOut != null)
            mouseOutEventRef = await MapEventJsInterop.SubscribeEvent(Id, "mouseout", OnMouseOut);

        if (OnMouseOver != null)
            mouseOverEventRef = await MapEventJsInterop.SubscribeEvent(Id, "mouseover", OnMouseOver);

        if (OnProjectionChanged != null)
            projectionChangedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "projection_changed", OnProjectionChanged);

        if (OnRightClick != null)
            rightClickEventRef = await MapEventJsInterop.SubscribeEvent(Id, "rightclick", OnRightClick);

        if (OnTilesLoaded != null)
            tilesLoadedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "tilesloaded", OnTilesLoaded);

        if (OnTiltChanged != null)
            tiltChangedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "tilt_changed", OnTiltChanged);

        if (OnZoomChanged != null)
            zoomChangedEventRef = await MapEventJsInterop.SubscribeEvent(Id, "zoom_changed", OnZoomChanged);
    }

    protected override bool ShouldRender()
    {
        var renderUI = false;

        return renderUI;
    }

    /// <summary>
    /// Sets the viewport to contain the given bounds.
    /// </summary>
    /// <param name="bounds"></param>
    /// <returns></returns>
    public async Task FitBounds(LatLngBoundsLiteral bounds)
    {
        await MapFunctionJsInterop.FitBounds(Id, bounds);
    }

    /// <summary>
    /// Changes the center of the map by the given distance in pixels. 
    /// If the distance is less than both the width and height of the map, the transition will be smoothly animated. 
    /// Note that the map coordinate system increases from west to east (for x values) and north to south (for y values).
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    public async Task PanBy(int x, int y)
    {
        await MapFunctionJsInterop.PanBy(Id, x, y);
    }

    /// <summary>
    /// Changes the center of the map to the given LatLng. 
    /// If the change is less than both the width and height of the map, the transition will be smoothly animated.
    /// </summary>
    /// <param name="latLng"></param>
    /// <returns></returns>
    public async Task PanTo(LatLngLiteral latLng)
    {
        await MapFunctionJsInterop.PanTo(Id, latLng);
    }

    /// <summary>
    /// Pans the map by the minimum amount necessary to contain the given LatLngBounds. 
    /// It makes no guarantee where on the map the bounds will be, except that the map will be panned to show as much of the bounds as possible inside {currentMapSizeInPx} - {padding}.
    /// </summary>
    /// <param name="latLngBounds"></param>
    /// <returns></returns>
    public async Task PanToBounds(LatLngBoundsLiteral latLngBounds)
    {
        await MapFunctionJsInterop.PanToBounds(Id, latLngBounds);
    }

    /// <summary>
    /// Returns the lat/lng bounds of the current viewport. 
    /// If more than one copy of the world is visible, the bounds range in longitude from -180 to 180 degrees inclusive. 
    /// If the map is not yet initialized (i.e. the mapType is still null), or center and zoom have not been set then the result is null.
    /// </summary>
    /// <returns></returns>
    public async Task<LatLngBoundsLiteral> GetBounds()
    {
        return await MapFunctionJsInterop.GetBounds(Id);
    }

    /// <summary>
    /// Returns the position displayed at the center of the map. 
    /// Note that this LatLng object is not wrapped.
    /// </summary>
    /// <returns></returns>
    public async Task<LatLngLiteral> GetCenter()
    {
        return await MapFunctionJsInterop.GetCenter(Id);
    }

    public async Task SetCenter(LatLngLiteral latLng)
    {
        await MapFunctionJsInterop.SetCenter(Id, latLng);
    }

    /// <summary>
    /// Returns the compass heading of aerial imagery. 
    /// The heading value is measured in degrees (clockwise) from cardinal direction North.
    /// </summary>
    /// <returns></returns>
    public async Task<int> GetHeading()
    {
        return await MapFunctionJsInterop.GetHeading(Id);
    }

    /// <summary>
    /// Sets the compass heading for aerial imagery measured in degrees from cardinal direction North.
    /// </summary>
    /// <param name="heading"></param>
    /// <returns></returns>
    public async Task SetHeading(int heading)
    {
        await MapFunctionJsInterop.SetHeading(Id, heading);
    }

    public async Task<MapTypeId> GetMapTypeId()
    {
        return await MapFunctionJsInterop.GetMapTypeId(Id);
    }

    public async Task SetMapTypeId(MapTypeId mapTypeId)
    {
        await MapFunctionJsInterop.SetMapTypeId(Id, mapTypeId);
    }

    /// <summary>
    /// Returns the current angle of incidence of the map, in degrees from the viewport plane to the map plane. 
    /// The result will be 0 for imagery taken directly overhead or 45 for 45° imagery. 45° imagery is only available for satellite and hybrid map types, within some locations, and at some zoom levels. 
    /// Note: This method does not return the value set by setTilt. 
    /// See setTilt for details.
    /// </summary>
    /// <returns></returns>
    public async Task<int> GetTilt()
    {
        return await MapFunctionJsInterop.GetTilt(Id);
    }

    /// <summary>
    /// Controls the automatic switching behavior for the angle of incidence of the map. 
    /// The only allowed values are 0 and 45. 
    /// setTilt(0) causes the map to always use a 0° overhead view regardless of the zoom level and viewport. 
    /// setTilt(45) causes the tilt angle to automatically switch to 45 whenever 45° imagery is available for the current zoom level and viewport, and switch back to 0 whenever 45° imagery is not available (this is the default behavior). 
    /// 45° imagery is only available for satellite and hybrid map types, within some locations, and at some zoom levels. Note: getTilt returns the current tilt angle, not the value set by setTilt. 
    /// Because getTilt and setTilt refer to different things, do not bind() the tilt property; doing so may yield unpredictable effects.
    /// </summary>
    /// <param name="tilt"></param>
    /// <returns></returns>
    public async Task SetTilt(int tilt)
    {
        await MapFunctionJsInterop.SetTilt(Id, tilt);
    }

    public async Task<int> GetZoom()
    {
        return await MapFunctionJsInterop.GetZoom(Id);
    }

    public async Task SetZoom(int zoom)
    {
        await MapFunctionJsInterop.SetZoom(Id, zoom);
    }
}